package features;

import java.io.*;
import java.text.*;


import java.util.*;

import java.util.regex.*;

//  perform input validation for car rental information
public class DataValidation {

    private static final Pattern SINGLE_LETTER_PATTERN = Pattern.compile("^[AM]$");

    // Regular expressions for  car name, date, time, and city name
    
    static Pattern PATTERN_FOR_CAR_NAME = Pattern.compile("^[a-zA-Z0-9\\s]+$");
    private static  Pattern RANGE_PATTERN = Pattern.compile("^\\d+-\\d+$");
    static Pattern PATTERN_FOR_DATE = Pattern.compile("^\\d{2}/\\d{2}/\\d{4}$"); //date format update
    static Pattern PATTERN_FOR_TIME = Pattern.compile("^(0?[1-9]|1[0-2])(:[0-5][0-9])?(\\s?[AP][M])?$");
    static Pattern PATTERN_NAME_FOR_CITY = Pattern.compile("^[a-zA-Z\\s]+$");
    static Pattern PATTERN_FOR_INTEGER = Pattern.compile("^-?\\d+$");

    //  to validate car name
    public static boolean validate_Car_Name(String name_Of_Car) {
        boolean check_ptrn = PATTERN_FOR_CAR_NAME.matcher(name_Of_Car).matches();
        if (!check_ptrn) {
            System.out.println("Car name os invalid! Enter proper car name.Apologies, please try again.\n");
        }
        return check_ptrn;
    }
// to validate integer for while loop cases
    public static boolean validate_Integer(int user_Response) {
        String response_String = String.valueOf(user_Response);
        boolean is_Valid = PATTERN_FOR_INTEGER.matcher(response_String).matches();

        if (!is_Valid) {
            System.out.println("Not a valid response. Please try again.");
        }

        return is_Valid;
    }

    // Method to validate date
    public static boolean is_Previous_Date(String input_Date) {
    	
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        sdf.setLenient(false);
        boolean ret=false;

        try {
            Date date = sdf.parse(input_Date);
            
            Date currentDate = new Date();

            // Check if the parsed date is before the current date
         
            String[] rt=currentDate.toString().split(" ");
            String[] rtp=date.toString().split(" ");
          
            
            if(get_MonthNumber(rtp[1]).compareTo(get_MonthNumber(rt[1])) < 0)
            {
            
            	ret=true;
            }
            if(get_MonthNumber(rtp[1]).compareTo(get_MonthNumber(rt[1])) == 0)
            {
           
                if(rtp[2].compareTo(rt[2]) < 0)
                                         ret=true;          
              
            }
            return ret;
            
        } catch (ParseException e) {
            // If there is a parsing error, handle it accordingly
            System.out.println("Invalid date format: " + input_Date);
            return false;
        }
        
    }
    private static Integer get_MonthNumber(String month_Name) {
        HashMap<String, Integer> hash_Map = new HashMap<>();
        hash_Map.put("Jan",1);
        hash_Map.put("Feb",2);
        hash_Map.put("Mar",3);
        hash_Map.put("Apr",4);
        hash_Map.put("May",5);
        hash_Map.put("Jun",6);
        hash_Map.put("Jul",7);
        hash_Map.put("Aug",8);
        hash_Map.put("Sep",9);
        hash_Map.put("Oct",10);
        hash_Map.put("Nov",11);
        hash_Map.put("Dec",12);

        return hash_Map.get(month_Name);
    }
    //static Pattern PTRN_FOR_DATE = Pattern.compile("^\\d{2}/\\d{2}/\\d{4}$"); //date formate update
    public static boolean validate_Date(String input_Date)
    {
    	boolean checkk_ptrn=false;
        if (is_Previous_Date(input_Date)) {
            System.out.println("The date is a previous date.");
        } else 
        {
        	  checkk_ptrn = PATTERN_FOR_DATE.matcher(input_Date).matches();
             if (!checkk_ptrn) {
                 System.out.println("date format is invalid. Please use the format dd/mm/yy. Kindly try again.");
             }
             return checkk_ptrn;
        }
        return checkk_ptrn;
    }
    
    public static boolean validate_returnDate(String pickup_Date,String return_Date)
    {
    	boolean checkk_ptrn=false;
    	 checkk_ptrn = PATTERN_FOR_DATE.matcher(return_Date).matches();
         if (!checkk_ptrn)
         {
                 System.out.println("date format is invalid. Please use the format dd/mm/yy. Kindly try again.");
                
         }
             
        if (is_Previous_Date(return_Date)) 
        {
            System.out.println("The date is a previous date.");
        }
        String[] rt=pickup_Date.toString().split("/");
        String[] rtp=return_Date.toString().split("/");
       
        
        if(rtp[1].compareTo(rt[1]) < 0)
        {
        	System.out.println("return month is previous months");
        	checkk_ptrn=false;
      	 
        	
        }
        if((rtp[1].compareTo(rt[1]) == 0) && (rtp[0].compareTo(rt[0]) < 0))
        {
        	System.out.println("return month is same but date is previous date");
        	checkk_ptrn=false;
        	 	
        }
        
       
             
       return checkk_ptrn;
    }
    

    // Method to validate time
    public static boolean validate_Time(String time) {
    	  
        boolean chk_ptrn = PATTERN_FOR_TIME.matcher(time).matches();
        if (!chk_ptrn) {
            System.out.println("Time format is invalid. Please use the format HH:MM. Kindly try again.");
        }
        return chk_ptrn;
    }

    // Method to validate city name
    // it first checks it is word or not then it checks with dictionary of words and gives similar word
    public static boolean validate_City_Name(String city_Name) {
        boolean check=false; 
       boolean str = PATTERN_NAME_FOR_CITY.matcher(city_Name).matches();
        if(str)
        {
        try 
        {
			SpellChecking.initialize_Dictionary("C:\\acc labs\\webscrapercarrental\\data\\dictionart.txt");
			 WordCompletion.initializeDictionary("C:\\acc labs\\webscrapercarrental\\data\\dictionart.txt");
			 check = SpellChecking.check_Spelling(city_Name);
			 //System.out.println(check);
		} catch (IOException e) 
        {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        if(check==false)
        {
        	System.out.println("Suggestions: for u r word");
        List<String> suggestions = WordCompletion.get_Suggestions(city_Name.toLowerCase());
       

        if (!suggestions.isEmpty())
        {
            

            for (int i = 0; i < suggestions.size(); i++)
            {

                System.out.println((i + 1) + ". " + suggestions.get(i));
            }
        }
        System.out.println("please select one from above.");
        }
        return check;
        }
        System.out.println("please type word correctly with letters");
        return str;
    }

    // Method to validate user response
    public static boolean validate_User_Response(String input) {
        if (input.length() == 1 && (input.charAt(0) == 'y' || input.charAt(0) == 'n')) {
            return true;
        } else {
            System.out.print("Invalid input. Please enter 'y' or 'n'\n");
            return false;
        }
    }
  // validating given input is number or not
    public static boolean validate_Range_Input(String input) {
        boolean check = RANGE_PATTERN.matcher(input).matches();

        if (!check) {
            System.out.println("Not a valid range. Please try again.");
        }
        return check;
    }
 // validating transimmiosn types
    public static boolean validate_TTypes(String preferredTransmission)
    {
        boolean check = SINGLE_LETTER_PATTERN.matcher(preferredTransmission).matches();
        if (!check){
            System.out.println("Invalid Selected Type. Please try again.");
        }
        return check;
    }
}
